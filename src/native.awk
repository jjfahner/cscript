#
# Script to generate native call stubs for cscript
#

# Setup separators
BEGIN {
  printf("/////////////////////////////////////////////////////////////////////\n");
  printf("//\n// Generated by stubgen.awk for cscript\n//\n");
};

##########################################################################
#
# Match class declarations
#

$0 ~ /^class [a-zA-Z0-9_]+$/ || 
$0 ~ /^class [a-zA-Z0-9_]+ +:/ {

  # Flush function table
  GenerateTable();
  
  # Store next classname
  className = $2;
  classIds[className] = 0;
}

##########################################################################
#
# Generate a method call
#

function GenerateTable()
{
  if(classStubs != "")
  {
    printf("NativeCall cscript_native_table_%s[] = \n{\n", className);
    printf("%s", classStubs);
    printf("  { stEmpty, 0, 0, 0, 0 }\n");
    printf("};\n\n");
  }
  classStubs = "";
}

##########################################################################
#
# Generate a method call
#

function GenerateMethod(name, type,
                        arg, sep, partype, parname, returns, stubname)
{
  # Generate stub name
  stubname = sprintf("cscript_native_method_%s_%s", className, name);

  # Generate stub prolog
  printf("static Value %s\n", stubname);
  printf("  (Evaluator* evaluator, Object* instance, Arguments const& arguments)\n");
  printf("{\n");
  
  # Generate function call
  returns = type == "void" ? "" : "return ";
  printf("  %sstatic_cast<%s*>(instance)->%s(", returns, className, name);
  
  # Generate parameters
  arg = 0;
  sep = " ";
  while(++i <= NF && $i != ")")
  {
    # Find name and type
    partype = "";
    parname = "";
    while($i != "," && $i != "=" && $i != ")")
    {
      partype = partype parname;
      parname = $i;
      ++i;
    }
    
    # Generate parameter
    if(partype == "ArgsCRef")
    {
      printf("\n    %sarguments", sep);
    }
    else if(partype == "EvalRef")
    {
      printf("\n    %s*evaluator", sep);
    }
    else
    {
      printf("\n    %scscript_arg_to_%s(arguments[%d])", sep, partype, arg++);
    }
    
    # Following args need comma
    sep = ","
  }
  
  # Close function call
  printf(");\n");
  
  # Generate return statement
  if(type == "void")
  {
    printf("  return Value();\n");
  }
  
  # Generate stub epilog
  printf("}\n");
  
  # Return the stub name
  return stubname;
}

function GenerateRoProp(name, type,
                        arg, sep, partype, parname, returns, stubname)
{
  # Generate stub name
  stubname = sprintf("cscript_native_roprop_%s_%s", className, name);

  # Generate stub prolog
  printf("static Value %s\n", stubname);
  printf("  (Object* instance)\n");
  printf("{\n");
  
  # Check return type
  if(type == "void")
  {
    printf("\n#error Invalid return type for property\n");
  }
  
  # Generate function call
  printf("  return static_cast<%s*>(instance)->%s();\n", className, name);
  
  # Generate stub epilog
  printf("}\n");
  
  # Return stub name
  return stubname;
}

##########################################################################
#
# Main parser
#

function GenerateRwProp(name, type,
                        arg, sep, partype, parname, returns)
{
  # Generate stub name
  stubname = sprintf("cscript_native_rwprop_%s_%s", className, name);

  # Generate stub prolog
  printf("static void %s\n", stubname);
  printf("  (Object* instance, Value const& value)\n");
  printf("{\n");
  
  # Generate function call
  printf("  static_cast<%s*>(instance)->Set%s(value);\n", className, name);
    
  # Generate stub epilog
  printf("}\n");
  
  # Return stub name
  return stubname;
}

##########################################################################
#
# Main parser
#

# Match native functions
$1 ~ /__native_method/ || 
$1 ~ /__native_roprop/ || 
$1 ~ /__native_rwprop/ {

  # Detect when the script moves to a new file
  if(filename != FILENAME)
  {
    # Store current name for matching
    filename = FILENAME;
    
    # Section delimiter
    printf("\n/////////////////////////////////////////////////////////////////////\n");
    
    # Generate an include statement
    file = gensub("\\\\", "/", "g", filename);
    file = gensub("include/",  "", "", file);
    printf("\n#include <%s>\n\n", file);
  }

  # Generate index for arrays
  idx = className classIds[className];
  
  # Store unmodified declaration
  stubDecls[idx] = $0;
  stubFiles[idx] = filename;

  # Separate punctuation from words
  gsub("\\).*$", " ) ");
  gsub("\\(", " ( ");
  gsub(",", " , ");
  gsub(";", " ; ");
  gsub("=", " = ");
  
  # Store stub type and discard
  stubTypes[idx] = $1;
  $1 = "";
  $0 = $0;
  
  # Discard any function specifiers
  while($1 == "virtual"  ||
        $1 == "static"   ||
        $1 == "inline"   ||
        $1 == "explicit" ||
        $1 == "static"   )
  {
    $1 = "";
    $0 = $0;
  }
  
  # Start parsing from first argument
  i = 1;
  
  # Parse type and name
  type = "";
  name = "";
  for(i = 1; i <= NF && $i != "("; ++i)
  {
    type = type name;
    name = $i;
  }
  
  # Check both
  if(type == "" || name == "")
  {
    print("Missing return type or method name\n");
    exit 1;
  }
  
  # Start stub line
  stubline = "  { ";
  
  # Generate proper type 
  if(stubTypes[idx] == "__native_method")
  {
    stubline = stubline "stMethod, \"" name "\", ";
    stubline = stubline GenerateMethod(name, type) ", ";
    stubline = stubline "0, 0";
  }
  if(stubTypes[idx] == "__native_roprop")
  {
    stubline = stubline "stRoProp, \"" name "\", 0, ";
    stubline = stubline GenerateRoProp(name, type) ", ";
    stubline = stubline "0";
  }
  if(stubTypes[idx] == "__native_rwprop")
  {
    stubline = stubline "stRwProp, \"" name "\", 0, ";
    stubline = stubline GenerateRoProp(name, type) ", ";
    stubline = stubline GenerateRwProp(name, type);
  }

  # Finish stub line
  stubline = stubline " },\n";
  
  # Add to stubs
  classStubs = classStubs stubline;
}

END {

  # Flush last table
  GenerateTable();
}
