//////////////////////////////////////////////////////////////////////////
//
// This file is © 2007 JJ Fahner <jan-jaap@jan-jaap.net>
// This file is part of the cscript interpreter.
// CScript can be found at http://svn.jan-jaap.net/
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
//////////////////////////////////////////////////////////////////////////

//
// Lemon language definition for cscript
//

//////////////////////////////////////////////////////////////////////////
//
// Include section
//
%include {

#include "ast.h"
#include "eval.h"
#include "tokens.h"
#include "astlist.h"
#include "convert.h"

#pragma warning(disable:4065)

} 
//
// End inclusion block
//
//////////////////////////////////////////////////////////////////////////

// Set prefix for tokens
%name             CScriptParse
%token_prefix     TOK_
%token_type       { Token }
%extra_argument   { Evaluator* p }
%default_type     { Ast* }

// Error handlers
%parse_failure {
  p->OnParseFailure();
}
%syntax_error {
  p->OnSyntaxError();
}

// Precedence rules for binary operators
%left LOGOR .
%left LOGAND .
%left BITOR .
%left BITXOR .
%left BITAND .
%left SEQ SNE .
%left EQUALS NEQUALS .
%left ST SE GT GE .
%left ADDOP SUBOP .
%left MULOP DIVOP MODOP .
%right ASSIGN ASSADD ASSSUB ASSMUL ASSDIV ASSMOD .

// Start symbol
main ::= translation_unit .

// Empty file
translation_unit ::= .

// Native declaration
translation_unit ::= native_declaration .

// Statement sequence
translation_unit ::= top_statement_sequence .

// Top-level statement sequence
top_statement_sequence ::= top_statement(A) .                        { if(A) p->EvalStatement(A); }
top_statement_sequence ::= top_statement_sequence top_statement(A) . { if(A) p->EvalStatement(A); }

// Top-level statements
top_statement(R) ::= include_statement(A) .     { R = A; }
top_statement(R) ::= expression_statement(A) .  { R = A; }
top_statement(R) ::= declaration_statement(A) . { R = A; }
top_statement(R) ::= for_statement(A) .         { R = A; }
top_statement(R) ::= compound_statement(A) .    { R = A; }
top_statement(R) ::= if_statement(A) .          { R = A; }
top_statement(R) ::= while_statement(A) .       { R = A; }
top_statement(R) ::= foreach_statement(A) .     { R = A; }
top_statement(R) ::= return_statement(A) .      { R = A; }
top_statement(R) ::= switch_statement(A) .      { R = A; }
top_statement(R) ::= extern_declaration(A) .    { R = A; }
top_statement(R) ::= try_statement(A) .         { R = A; }
top_statement(R) ::= error .                    { R = 0; }

// Statement sequence
statement_sequence(R) ::= statement(A) . { R = A; }
statement_sequence(R) ::= statement_sequence(A) statement(B) . { 
  if(A->m_type == statement_sequence) {
    R = A;
  }
  else {
    R = p->AllocAst(statement_sequence, new AstList);
    R->m_a1.GetList()->push_back(A);
  }
  R->m_a1.GetList()->push_back(B);
}

// Statement
statement(R) ::= expression_statement(A) .  { R = A; }
statement(R) ::= vardecl_statement(A) .     { R = A; }
statement(R) ::= for_statement(A) .         { R = A; }
statement(R) ::= compound_statement(A) .    { R = A; }
statement(R) ::= if_statement(A) .          { R = A; }
statement(R) ::= while_statement(A) .       { R = A; }
statement(R) ::= foreach_statement(A) .     { R = A; }
statement(R) ::= return_statement(A) .      { R = A; }
statement(R) ::= switch_statement(A) .      { R = A; }
statement(R) ::= break_statement(A) .       { R = A; }
statement(R) ::= continue_statement(A) .    { R = A; }
statement(R) ::= try_statement(A) .         { R = A; }
statement(R) ::= throw_statement(A) .       { R = A; }
statement(R) ::= error .                    { R = 0; }

//////////////////////////////////////////////////////////////////////////
//
// Expressions
//

// Expression
expression(R) ::= assignment_expression(A) . { R = A; }

// Optional expression
expression_opt(R) ::= .               { R = 0; }
expression_opt(R) ::= expression(A) . { R = A; }

// Assignment
assignment_expression(R) ::= conditional_expression(A) . { R = A; }
assignment_expression(R) ::= binary_expression(A) assignment_operator(T) assignment_expression(B) . { R = p->AllocAst(assignment_expression, T, A, B); }

// Assignment operator
%type assignment_operator { opcodes }
assignment_operator(R) ::= ASSIGN . { R = op_assign; }
assignment_operator(R) ::= ASSADD . { R = op_assadd; }
assignment_operator(R) ::= ASSSUB . { R = op_asssub; }
assignment_operator(R) ::= ASSMUL . { R = op_assmul; }
assignment_operator(R) ::= ASSDIV . { R = op_assdiv; }
assignment_operator(R) ::= ASSMOD . { R = op_assmod; }

// Conditional
conditional_expression(R) ::= binary_expression(A) . { R = A; }
conditional_expression(R) ::= binary_expression(A) QUESTION expression(B) COLON assignment_expression(C) . { R = p->AllocAst(ternary_expression, A, B, C); }

// Binary expressions
binary_expression(R) ::= unary_expression(A) . { R = A; }
binary_expression(R) ::= binary_expression(A) LOGOR   binary_expression(B). { R = p->AllocAst(binary_expression, op_logor,   A, B); }
binary_expression(R) ::= binary_expression(A) LOGAND  binary_expression(B). { R = p->AllocAst(binary_expression, op_logand,  A, B); }
binary_expression(R) ::= binary_expression(A) BITOR   binary_expression(B). { R = p->AllocAst(binary_expression, op_bitor,   A, B); }
binary_expression(R) ::= binary_expression(A) BITXOR  binary_expression(B). { R = p->AllocAst(binary_expression, op_bitxor,  A, B); }
binary_expression(R) ::= binary_expression(A) BITAND  binary_expression(B). { R = p->AllocAst(binary_expression, op_bitand,  A, B); }
binary_expression(R) ::= binary_expression(A) EQUALS  binary_expression(B). { R = p->AllocAst(binary_expression, op_eq,   A, B); }
binary_expression(R) ::= binary_expression(A) NEQUALS binary_expression(B). { R = p->AllocAst(binary_expression, op_ne,   A, B); }
binary_expression(R) ::= binary_expression(A) ST      binary_expression(B). { R = p->AllocAst(binary_expression, op_lt,   A, B); }
binary_expression(R) ::= binary_expression(A) SE      binary_expression(B). { R = p->AllocAst(binary_expression, op_le,   A, B); }
binary_expression(R) ::= binary_expression(A) GT      binary_expression(B). { R = p->AllocAst(binary_expression, op_gt,   A, B); }
binary_expression(R) ::= binary_expression(A) GE      binary_expression(B). { R = p->AllocAst(binary_expression, op_ge,   A, B); }
binary_expression(R) ::= binary_expression(A) ADDOP   binary_expression(B). { R = p->AllocAst(binary_expression, op_add,  A, B); }
binary_expression(R) ::= binary_expression(A) SUBOP   binary_expression(B). { R = p->AllocAst(binary_expression, op_sub,  A, B); }
binary_expression(R) ::= binary_expression(A) MULOP   binary_expression(B). { R = p->AllocAst(binary_expression, op_mul,  A, B); }
binary_expression(R) ::= binary_expression(A) DIVOP   binary_expression(B). { R = p->AllocAst(binary_expression, op_div,  A, B); }
binary_expression(R) ::= binary_expression(A) MODOP   binary_expression(B). { R = p->AllocAst(binary_expression, op_mod,  A, B); }
binary_expression(R) ::= binary_expression(A) SEQ     binary_expression(B). { R = p->AllocAst(binary_expression, op_seq,  A, B); }
binary_expression(R) ::= binary_expression(A) SNE     binary_expression(B). { R = p->AllocAst(binary_expression, op_sne,  A, B); }

// Unary expression
unary_expression(R) ::= postfix_expression(A) .      { R = A; } 
unary_expression(R) ::= SUBOP  unary_expression(A) . { R = p->AllocAst(prefix_expression, op_negate, A); }
unary_expression(R) ::= ADDADD unary_expression(A) . { R = p->AllocAst(prefix_expression, op_preinc, A); }
unary_expression(R) ::= SUBSUB unary_expression(A) . { R = p->AllocAst(prefix_expression, op_predec, A); }
unary_expression(R) ::= NOT unary_expression(A) .    { R = p->AllocAst(prefix_expression, op_not,    A); }
unary_expression(R) ::= new_expression(A) .          { R = A; }

// Postfix expression
postfix_expression(R) ::= primary_expression(A) .                                 { R = A; }
postfix_expression(R) ::= postfix_expression(A) ADDADD .                          { R = p->AllocAst(postfix_expression, op_postinc, A); }
postfix_expression(R) ::= postfix_expression(A) SUBSUB .                          { R = p->AllocAst(postfix_expression, op_postdec, A); }
postfix_expression(R) ::= function_call(A) .                                      { R = A; }
postfix_expression(R) ::= postfix_expression(A) DOT IDENTIFIER(B).                { R = p->AllocAst(member_expression, A, String(B)); }
postfix_expression(R) ::= postfix_expression(A) DOT function_call(B) .            { R = B; B->m_a3 = A; }
postfix_expression(R) ::= postfix_expression(A) LBRACKET expression(B) RBRACKET.  { R = p->AllocAst(index_expression, A, B); }

// Primary expression
primary_expression(R) ::= literal(A) .                  { R = A; }
primary_expression(R) ::= id_expression(A) .            { R = A; }
primary_expression(R) ::= LPAREN expression(A) RPAREN . { R = A; }
primary_expression(R) ::= list_literal(A) .             { R = A; }
primary_expression(R) ::= THIS .                        { R = p->AllocAst(this_expression); }
primary_expression(R) ::= type(A) LPAREN expression(B) RPAREN . { R = p->AllocAst(conversion_expression, A, B); }

// Literals
literal(R) ::= LIT_INTEGER(A) . { R = p->AllocAst(literal_value, Value(str2dec(String(A).c_str()))); }
literal(R) ::= LIT_HEX(A) .     { R = p->AllocAst(literal_value, Value(hex2dec(String(A).c_str()))); }
literal(R) ::= LIT_BIN(A) .     { R = p->AllocAst(literal_value, Value(bin2dec(String(A).c_str()))); }
literal(R) ::= LIT_ROM(A) .     { R = p->AllocAst(literal_value, Value(rom2dec(String(A).c_str()))); }
literal(R) ::= LIT_REAL(A) .    { R = p->AllocAst(literal_value, Value(str2flt(String(A).c_str()))); } 
literal(R) ::= LIT_STRING(A) .  { R = p->AllocAst(literal_value, Value(String(A))); }
literal(R) ::= TRUE .           { R = p->AllocAst(literal_value, Value(true));    }
literal(R) ::= FALSE .          { R = p->AllocAst(literal_value, Value(false));   }
literal(R) ::= NULL .           { R = p->AllocAst(literal_value, Value());        }

// Id expression
id_expression(R) ::= IDENTIFIER(A) . { R = p->AllocAst(lvalue, String(A)); }

// List definition
list_literal(R) ::= LBRACKET list_content(A) RBRACKET . { R = p->AllocAst(list_literal, A); }
list_content(R) ::= list_entry(A) . { R = p->AllocAst(list_content, A); }
list_content(R) ::= list_entry(A) COMMA list_content(B) . { R = p->AllocAst(list_content, A, B); }

list_entry(R)   ::= expression(A) . { R = p->AllocAst(list_entry, A); }

// New expression
new_expression(R) ::= NEW type(A) .                                { R = p->AllocAst(new_expression, A, p->AllocAst(positional_arguments, new AstList)); }
new_expression(R) ::= NEW type(A) LPAREN argument_list(B) RPAREN . { R = p->AllocAst(new_expression, A, B); }

//////////////////////////////////////////////////////////////////////////
//
// Types
//

type(R) ::= BOOL(A) .   { R = new Ast(type_specifier, Value::tBool,   String(A)); }
type(R) ::= INT(A) .    { R = new Ast(type_specifier, Value::tInt,    String(A)); }
type(R) ::= STRING(A) . { R = new Ast(type_specifier, Value::tString, String(A)); }
type(R) ::= TYPE(A) .   { R = new Ast(type_specifier, Value::tObject, String(A)); }

//////////////////////////////////////////////////////////////////////////
//
// Function calls
//

// Function call
function_call(R) ::= IDENTIFIER(A) LPAREN argument_list(B) RPAREN . { R = p->AllocAst(function_call, String(A), B); }

// Positional argument
positional_argument(R) ::= expression(A) . { R = A; }

// Argument list containing 1 or more positional arguments
%type positional_argument_list { AstList* }
positional_argument_list(R) ::= positional_argument(A) . { R = new AstList; R->push_back(A); }
positional_argument_list(R) ::= positional_argument_list(A) COMMA positional_argument(B) . { R = A; A->push_back(B); }

// Named argument
named_argument(R) ::= IDENTIFIER(A) COLON expression(B) . { R = p->AllocAst(named_argument, String(A), B); }

// Argument list containing 1 or more named arguments
%type named_argument_list { AstList* }
named_argument_list(R) ::= named_argument(A) . { R = new AstList; R->push_back(A); }
named_argument_list(R) ::= named_argument_list(A) COMMA named_argument(B) . { R = A; A->push_back(B); }

// Argument list
argument_list(R) ::= .                              { R = p->AllocAst(positional_arguments, new AstList); }
argument_list(R) ::= positional_argument_list(A) .  { R = p->AllocAst(positional_arguments, A); }
argument_list(R) ::= named_argument_list(A) .       { R = p->AllocAst(named_arguments,      A); }

//////////////////////////////////////////////////////////////////////////
//
// Simple statements
//

// Expression statement
expression_statement(R) ::= SEMICOLON .               { R = p->AllocAst(empty_statement); }
expression_statement(R) ::= expression(A) SEMICOLON . { R = p->AllocAst(expression_statement, A); }

// Compound statement
compound_statement(R) ::= LBRACE RBRACE .                       { R = p->AllocAst(compound_statement); }
compound_statement(R) ::= LBRACE statement_sequence(A) RBRACE . { R = p->AllocAst(compound_statement, A); }

// Include statement
include_statement(R) ::= INCLUDE LIT_STRING(A) SEMICOLON . { p->ParseFile(A); R = 0; }

// Return statement - leaves return expression on the stack
return_statement(R) ::= RETURN expression(A) SEMICOLON . { R = p->AllocAst(return_statement, A); }
return_statement(R) ::= RETURN SEMICOLON .               { R = p->AllocAst(return_statement);    }

// Break/continue
break_statement(R)    ::= BREAK SEMICOLON .    { R = p->AllocAst(break_statement); }
continue_statement(R) ::= CONTINUE SEMICOLON . { R = p->AllocAst(continue_statement); }

//////////////////////////////////////////////////////////////////////////
//
// Variable declaration
//

// Declaration starting point
declaration_statement(R) ::= function_declaration(A) . { R = A; }
declaration_statement(R) ::= class_declaration(A)  .   { R = A; }
declaration_statement(R) ::= vardecl_statement(A) .    { R = A; }

vardecl_statement(R) ::= variable_declaration(A) SEMICOLON .      { R = A; }

variable_declaration(R) ::= VAR declarator_sequence(A) . { R = A; }

declarator(R) ::= IDENTIFIER(A) .                      { R = p->AllocAst(variable_declaration, String(A));    }
declarator(R) ::= IDENTIFIER(A) ASSIGN expression(B) . { R = p->AllocAst(variable_declaration, String(A), B); }

declarator_sequence(R) ::= declarator(A) . { R = A; }
declarator_sequence(R) ::= declarator_sequence(A) COMMA declarator(B) . { R = p->AllocAst(declaration_sequence, A, B); }

//////////////////////////////////////////////////////////////////////////
//
// Class declaration
//

// Class split into header and body to ensure early registration of the class name
class_declaration(R) ::= class_start(A) LBRACE                  RBRACE . { R = A; A->m_a2 = new AstList; }
class_declaration(R) ::= class_start(A) LBRACE class_members(B) RBRACE . { R = A; A->m_a2 = B; }

// Class start
class_start(R) ::= CLASS IDENTIFIER(A) .  { R = p->AllocAst(class_declaration, String(A)); }
class_start    ::= CLASS TYPE .           { throw std::runtime_error("Class already declared"); }

// Class members
class_member(R) ::= variable_declaration(A) SEMICOLON . { R = A; }
class_member(R) ::= function_declaration(A) .           { R = A; }
class_member(R) ::= conversion_operator(A) .            { R = A; }
class_member(R) ::= constructor(A) .                    { R = A; }
class_member(R) ::= destructor(A) .                     { R = A; }

// Constructor
constructor(R) ::= type(A) LPAREN parameter_list(B) RPAREN compound_statement(C) . { R = p->AllocAst(constructor, A, B, C); }

// Destructor
destructor(R) ::= TILDE type(A) LPAREN RPAREN compound_statement(B) . { R = p->AllocAst(destructor, A, new AstList, B); }

// Conversion operator - make sure to have approx. the same layout as for regular functions
conversion_operator(R) ::= OPERATOR type(A) LPAREN RPAREN compound_statement(B) . { R = p->AllocAst(conversion_operator, A, new AstList, B); }

// Class members
%type class_members { AstList* }
class_members(R) ::= class_member(A) . { 
  R = new AstList;
  R->push_back(A);
}
class_members(R) ::= class_members(A) class_member(B) . { 
  R = A;
  R->push_back(B);
}

//////////////////////////////////////////////////////////////////////////
//
// Function declaration
//

// Native declaration
native_declaration ::= NATIVE IDENTIFIER(A) LPAREN parameter_list(B) RPAREN . { p->m_native = p->AllocAst(function_declaration, String(A), B); }

// Function declaration
function_declaration(R) ::= FUNCTION IDENTIFIER(A) LPAREN parameter_list(B) RPAREN function_body(C) . { R = p->AllocAst(function_declaration, String(A), B, C); }

// Single parameter
parameter(R) ::= type(A) IDENTIFIER(B) .        { R = p->AllocAst(parameter, String(B), ptByVal, A); }
parameter(R) ::=         IDENTIFIER(B) .        { R = p->AllocAst(parameter, String(B), ptByVal);    }
parameter(R) ::= type(A) BITAND IDENTIFIER(B) . { R = p->AllocAst(parameter, String(B), ptByRef, A); }
parameter(R) ::=         BITAND IDENTIFIER(B) . { R = p->AllocAst(parameter, String(B), ptByRef);    }

// Single optional parameter
opt_parameter(R) ::= type(A) IDENTIFIER(B) ASSIGN expression(C) . { R = p->AllocAst(parameter, String(B), ptByVal, A,         C); }
opt_parameter(R) ::=         IDENTIFIER(B) ASSIGN expression(C) . { R = p->AllocAst(parameter, String(B), ptByVal, AstData(), C); }

// Variadic argument
variadic_parameter(R) ::= IDENTIFIER(A) VARIADIC . { R = p->AllocAst(parameter, String(A), ptVariadic); }

// Parameter list
%type parameter_list { AstList* }
parameter_list(R) ::= . { R = new AstList; }
parameter_list(R) ::= parameters(A)     . { R = A; }
parameter_list(R) ::= opt_parameters(A) . { R = A; }
parameter_list(R) ::= variadic_parameter(A) . { R = new AstList; R->push_back(A); }
parameter_list(R) ::= parameters(A) COMMA opt_parameters(B) . { R = A; A->adopt(*B); }
parameter_list(R) ::= parameters(A) COMMA variadic_parameter(B) . { R = A; A->push_back(B); }

// List of parameters
%type parameters { AstList* }
parameters(R) ::= parameter(A) . { R = new AstList; R->push_back(A); }
parameters(R) ::= parameters(A) COMMA parameter(B) . { R = A; A->push_back(B); }

// List of optional parameters
%type opt_parameters { AstList* }
opt_parameters(R) ::= opt_parameter(A) . { R = new AstList; R->push_back(A); }
opt_parameters(R) ::= opt_parameters(A) COMMA opt_parameter(B) . { R = A; A->push_back(B); }

// Function body. Traditionally, this is a compound statement, but
// there's no actual need for that.
function_body(R) ::= statement(A) . { R = A; }

//////////////////////////////////////////////////////////////////////////
//
// External function declaration
//

extern_declaration(R) ::= EXTERN LIT_STRING(A) type(B) IDENTIFIER(C) 
  LPAREN parameter_list(D) RPAREN SEMICOLON . 
{ 
  R = new Ast(extern_declaration, String(C), D, String(A), B); 
}

//////////////////////////////////////////////////////////////////////////
//
// For statement
//

// For statement - main structure
for_statement(R) ::= FOR LPAREN for_init_statement(A) expression(B) SEMICOLON expression_opt(C) RPAREN statement(D) . { R = p->AllocAst(for_statement, A, B, C, D); }

// For init statement
for_init_statement(R) ::= expression_statement(A) .           { R = A; }
for_init_statement(R) ::= variable_declaration(A) SEMICOLON . { R = A; }

//////////////////////////////////////////////////////////////////////////
//
// Foreach statement
//

foreach_statement(R) ::= FOR LPAREN id_expression(A) IN expression(B) RPAREN statement(C) . { R = p->AllocAst(foreach_statement, A, B, C); }
foreach_statement(R) ::= FOR LPAREN foreach_decl(A)  IN expression(B) RPAREN statement(C) . { R = p->AllocAst(foreach_statement, A, B, C); }
foreach_decl(R)      ::= VAR IDENTIFIER(A) . { R = p->AllocAst(variable_declaration, String(A)); }

//////////////////////////////////////////////////////////////////////////
//
// If statement
//

%left LOWER_THAN_ELSE.
%left ELSE.

// Main if statement
if_statement(R) ::= IF LPAREN expression(A) RPAREN statement(B) . [LOWER_THAN_ELSE] { R = p->AllocAst(if_statement, A, B); } 
if_statement(R) ::= IF LPAREN expression(A) RPAREN statement(B) ELSE statement(C) . { R = p->AllocAst(if_statement, A, B, C); }

//////////////////////////////////////////////////////////////////////////
//
// While statement
//

// Basic while
while_statement(R) ::= WHILE LPAREN expression(A) RPAREN statement(B) . { R = p->AllocAst(while_statement, A,  B); }

//////////////////////////////////////////////////////////////////////////
//
// Switch statement
//

// Main switch statement
switch_statement(R) ::= SWITCH LPAREN expression(A) RPAREN LBRACE switch_body(B) RBRACE . { R = p->AllocAst(switch_statement, A, B); }

// Switch content
%type switch_body { AstList* }
switch_body(R) ::= . { R = new AstList; }
switch_body(R) ::= switch_body(A) switch_case(B)  . { R = A; R->push_back(B); }
switch_body(R) ::= switch_body(A) default_case(B) . { R = A; R->push_back(B); }

// Regular case
switch_case(R) ::= CASE literal(A) COLON case_statements(B) . { R = p->AllocAst(switch_case, A, B); }

// Default case
default_case(R) ::= DEFAULT COLON case_statements(A) . { R = p->AllocAst(default_case, A); }

// Case content
case_statements(R) ::= statement_sequence(A) . { R = A; }

//////////////////////////////////////////////////////////////////////////
//
// Exception handling
//

try_statement(R) ::= TRY compound_statement(A) catch_block(B) .                   { R = p->AllocAst(try_statement, A, B); }
try_statement(R) ::= TRY compound_statement(A) finally_block(B) .                 { R = p->AllocAst(try_statement, A, AstData(), B); }
try_statement(R) ::= TRY compound_statement(A) catch_block(B) finally_block(C) .  { R = p->AllocAst(try_statement, A, B, C); }

catch_block(R) ::= CATCH LPAREN IDENTIFIER(A) RPAREN compound_statement(B) . { R = p->AllocAst(catch_block, String(A), B); }

finally_block(R) ::= FINALLY compound_statement(A) . { R = p->AllocAst(finally_block, A); }

throw_statement(R) ::= THROW expression(A) SEMICOLON . { R = p->AllocAst(throw_statement, A); }
