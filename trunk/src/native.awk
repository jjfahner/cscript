#
# Script to generate native call stubs for cscript
#

# Setup separators
BEGIN {
  printf("/////////////////////////////////////////////////////////////////////\n");
  printf("//\n// Generated by stubgen.awk for cscript\n//\n");
};

##########################################################################
#
# Match class declarations
#

$0 ~ /class [a-zA-Z0-9_]+$/ || 
$0 ~ /class [a-zA-Z0-9_]+ +:/ {

  # Flush function table
  GenerateTable();
  
  # Check for constructable
  namePos = 2;
  if($1 == "__native_construct")
  {
    namePos = 3;  
  }

  # Store next classname
  className = $namePos;
  classIds[className] = 0;
  
  # Store constructable
  if(namePos == 3)
  {
    genConstructables = 1;
    constructable[className] = 1;
  }
  
  # Store class in array
  classes[length(classes) + 1] = className;
}

##########################################################################
#
# Generate a method call
#

function GenerateTable()
{
  if(classStubs != "")
  {
    printf("NativeCall cscript_native_table_%s[] = \n{\n", className);
    printf("%s", classStubs);
    printf("  { stEmpty, 0, 0, 0, 0 }\n");
    printf("};\n\n");
    
    if(constructable[className] == 1)
    {
      printf("static Value cscript_native_constructor_%s()\n{\n  return new %s();\n}\n", \
        className, className, className);  
    }
  }
  
  classStubs = "";
}

##########################################################################
#
# Method call
#

function GenerateMethod(name, type,
                        arg, sep, num, partype, parname, returns, stubname)
{
  # Generate stub name
  stubname = sprintf("cscript_native_method_%s_%s", className, name);

  # Generate stub prolog
  printf("static Value %s\n", stubname);
  printf("  (Object* instance, Arguments const& arguments)\n");
  printf("{\n");
  
  # Generate function call
  returns = type == "void" ? "" : "return ";
  call = sprintf("  %sstatic_cast<%s*>(instance)->%s(", returns, className, name);

  # Generate parameters
  arg = 0;
  sep = " ";
  num = 0;
  parnum = 0;
  while(++i <= NF && $i != ")")
  {
    # Find name, type, and default value
    partype  = "";
    parname  = "";
    parvalue = "";
    while($i != "," && $i != ")")
    {
      partype = partype parname;
      parname = $i;
      ++i;
      
      # Parse default value
      if($i == "=")
      {
        ++i;
        #brackets = 0;
        #while($i != "," && $i != ")")
        #{
        #  if($i == "(")
        #  {
        #    ++brackets;
        #  }
        #  if($i == ")")          
        #  {
        #    --brackets;
        #  }
        #  if(brackets < 0)
        #  {
        #    break;
        #  }
        #  parvalue = parvalue $i;
        #  ++i;
        #}
        parvalue = parvalue $i;
        ++i;
      }
    }
    ++parnum;

    # Generate parameter
    if(partype == "ArgsCRef")
    {
      call = call sprintf("\n    %sarguments", sep);
    }
    else if(partype == "EvalRef")
    {
      call = call sprintf("\n    %sCurEval", sep);
    }
    else if(parvalue != "")
    {
      call = call sprintf("\n    %sarguments.size() < %i ? %s : cscript_arg_to_%s(arguments[%d])", sep, parnum, parvalue, partype, arg++);
    }
    else
    {
      call = call sprintf("\n    %scscript_arg_to_%s(arguments[%d])", sep, partype, arg++);
      ++num;
    }
    
    # Following args need comma
    sep = ","
  }
  
  # Close function call
  call = call sprintf(");\n");
  
  # Generate argument count check
  printf("  cscript_check_argcount(\"%s\", \"%s\", %d, arguments.size());\n", className, name, num);
  
  # Generate call to member
  printf(call);
  
  # Generate return statement
  if(type == "void")
  {
    printf("  return Value();\n");
  }
  
  # Generate stub epilog
  printf("}\n");
  
  # Return the stub name
  return stubname;
}

##########################################################################
#
# Read-only property
#

function GenerateRoProp(name, type,
                        arg, sep, partype, parname, returns, stubname)
{
  # Generate stub name
  stubname = sprintf("cscript_native_roprop_%s_%s", className, name);

  # Generate stub prolog
  printf("static Value %s\n", stubname);
  printf("  (Object* instance)\n");
  printf("{\n");
  
  # Check return type
  if(type == "void")
  {
    printf("\n#error Invalid return type for property\n");
  }
  
  # Generate function call
  printf("  return static_cast<%s*>(instance)->%s();\n", className, name);
  
  # Generate stub epilog
  printf("}\n");
  
  # Return stub name
  return stubname;
}

##########################################################################
#
# Read-write property
#

function GenerateRwProp(name, type,
                        arg, sep, partype, parname, returns)
{
  # Generate stub name
  stubname = sprintf("cscript_native_rwprop_%s_%s", className, name);

  # Generate stub prolog
  printf("static void %s\n", stubname);
  printf("  (Object* instance, Value const& value)\n");
  printf("{\n");
  
  # Generate function call
  printf("  static_cast<%s*>(instance)->Set%s(value);\n", className, name);
    
  # Generate stub epilog
  printf("}\n");
  
  # Return stub name
  return stubname;
}

##########################################################################
#
# Main parser
#

# Match native functions
$1 ~ /__native_method/ || 
$1 ~ /__native_roprop/ || 
$1 ~ /__native_rwprop/ {

  # Detect when the script moves to a new file
  if(filename != FILENAME)
  {
    # Store current name for matching
    filename = FILENAME;
    
    # Section delimiter
    printf("\n/////////////////////////////////////////////////////////////////////\n");
    
    # Generate an include statement
    printf("\n#include <%s>\n\n", filename);
  }

  # Generate index for arrays
  idx = className classIds[className];
  
  # Store unmodified declaration
  stubDecls[idx] = $0;
  stubFiles[idx] = filename;

  # Separate punctuation from words
  gsub("\\).*$", " ) ");
  gsub("\\(", " ( ");
  gsub(",", " , ");
  gsub(";", " ; ");
  gsub("=", " = ");
  
  print $0 >> "wtf.txt";
  
  # Store stub type and discard
  stubTypes[idx] = $1;
  $1 = "";
  $0 = $0;
  
  # Discard any function specifiers
  while($1 == "virtual"  ||
        $1 == "static"   ||
        $1 == "inline"   ||
        $1 == "explicit" ||
        $1 == "static"   )
  {
    $1 = "";
    $0 = $0;
  }
  
  # Start parsing from first argument
  i = 1;
  
  # Parse type and name
  type = "";
  name = "";
  for(i = 1; i <= NF && $i != "("; ++i)
  {
    type = type name;
    name = $i;
  }
  
  # Check both
  if(type == "" || name == "")
  {
    print("Missing return type or method name\n");
    exit 1;
  }
  
  # Start stub line
  stubline = "  { ";
  
  # Generate proper type 
  if(stubTypes[idx] == "__native_method")
  {
    stubline = stubline "stMethod, \"" name "\", ";
    stubline = stubline GenerateMethod(name, type) ", ";
    stubline = stubline "0, 0";
  }
  if(stubTypes[idx] == "__native_roprop")
  {
    stubline = stubline "stRoProp, \"" name "\", 0, ";
    stubline = stubline GenerateRoProp(name, type) ", ";
    stubline = stubline "0";
  }
  if(stubTypes[idx] == "__native_rwprop")
  {
    stubline = stubline "stRwProp, \"" name "\", 0, ";
    stubline = stubline GenerateRoProp(name, type) ", ";
    stubline = stubline GenerateRwProp(name, type);
  }

  # Finish stub line
  stubline = stubline " },\n";
  
  # Add to stubs
  classStubs = classStubs stubline;
}

END {

  # Flush last table
  GenerateTable();
  
  # Generate constructor table
  if(genConstructables == 1)
  {
    printf("NativeConstructor cscript_native_constructors[] = {\n");
    for(className in constructable)
    {
      if(constructable[className] == 0) {
        continue;
      }
      printf("  { \"%s\", cscript_native_constructor_%s },\n", className, className);
    }
    printf("  { 0, 0 }\n};\n\n");  
  }
  
  # Output end of file 
  printf("// EOF\n\n");
}
