//////////////////////////////////////////////////////////////////////////
//
// Lemon language definition for cscript
//
//////////////////////////////////////////////////////////////////////////

// Set prefix for tokens
%name             CScriptParse
%token_prefix     TOK_
%token_type       { Token }
%extra_argument   { Parser* p }

// Error handlers
%parse_failure {
  throw std::runtime_error("Parse failed");
}
%syntax_error {
  throw std::runtime_error("Syntax error");
}

//////////////////////////////////////////////////////////////////////////
//
// Include section
//
%include {

#include "tokens.h"
#include "parser.h"

#pragma warning(disable:4065)

//
// Some defines to make the code a bit cleaner
//
#define INS(arg)      (p->PushByte(TOK_##arg))
#define PUSHB(arg)    (p->PushByte(arg))
#define PUSHW(arg)    (p->PushWord(arg))
#define PUSHQ(arg)    (p->PushQuad(arg))
#define PUSHFRAME()   (p->PushFrame())
#define POPFRAME()    (p->PopFrame())
#define PATCH(arg)    (p->SetQuad(p->PopOffset(arg), p->GetPos()))
#define PUSHCALL(arg) (p->PushCall(arg))
#define POPCALL()     (p->PopCall())
#define PUSHARG()     (p->PushArg())

} 
//
// End inclusion block
//
//////////////////////////////////////////////////////////////////////////


// Precedence rules for binary operators
%left LOGOR .
%left LOGAND .
%left BITOR .
%left BITXOR .
%left BITAND .
%left EQUALS NEQUALS .
%left ST SE GT GE .
%left ADDOP SUBOP .
%left MULOP DIVOP MODOP .
%right ASSIGN ASSADD ASSSUB ASSMUL ASSDIV ASSMOD .


// Start symbol
translation_unit ::= statement_sequence_opt.

// Statement sequence
statement_sequence ::= statement. 
statement_sequence ::= statement_sequence statement. 

// Optional statement sequence
statement_sequence_opt ::= . 
statement_sequence_opt ::= statement_sequence. 

// Statement
statement ::= include_statement .
statement ::= expression_statement . 
statement ::= declaration_statement .
statement ::= for_statement .
statement ::= compound_statement .
statement ::= if_statement .
statement ::= while_statement .
statement ::= foreach_statement .

// Expression
expression ::= assignment_expression.

// Optional expression
expression_opt ::= .
expression_opt ::= expression .

// Assignment
assignment_expression ::= conditional_expression . 
assignment_expression ::= binary_expression ASSIGN assignment_expression. { INS(ASSIGN); }
assignment_expression ::= binary_expression ASSADD assignment_expression. { INS(ASSADD); } 
assignment_expression ::= binary_expression ASSSUB assignment_expression. { INS(ASSSUB); }
assignment_expression ::= binary_expression ASSMUL assignment_expression. { INS(ASSMUL); }
assignment_expression ::= binary_expression ASSDIV assignment_expression. { INS(ASSDIV); }
assignment_expression ::= binary_expression ASSMOD assignment_expression. { INS(ASSMOD); }

// Conditional
conditional_expression ::= binary_expression .
conditional_expression ::= cond_part QUESTION cond_expr_true COLON cond_expr_false . 

// Contitional parts
cond_part ::= binary_expression . {
  INS(JZ);
  p->PushOffset("cond_exp_1");
  PUSHQ(0);
}
cond_expr_true ::= expression . {
  INS(JMP);
  p->PushOffset("cond_exp_2");
  PUSHQ(0);
  p->SetQuad(p->PopOffset("cond_exp_1"), p->GetPos());
}
cond_expr_false ::= assignment_expression . {
  p->SetQuad(p->PopOffset("cond_exp_2"), p->GetPos());
}

// Binary expressions
binary_expression ::= unary_expression . 
binary_expression ::= binary_expression LOGOR   binary_expression. { INS(LOGOR);   }
binary_expression ::= binary_expression LOGAND  binary_expression. { INS(LOGAND);  }
binary_expression ::= binary_expression BITOR   binary_expression. { INS(PREINC);  }
binary_expression ::= binary_expression BITXOR  binary_expression. { INS(BITXOR);  }
binary_expression ::= binary_expression BITAND  binary_expression. { INS(BITAND);  }
binary_expression ::= binary_expression EQUALS  binary_expression. { INS(EQUALS);  }
binary_expression ::= binary_expression NEQUALS binary_expression. { INS(NEQUALS); }
binary_expression ::= binary_expression ST      binary_expression. { INS(ST);      }
binary_expression ::= binary_expression SE      binary_expression. { INS(SE);      }
binary_expression ::= binary_expression GT      binary_expression. { INS(GT);      }
binary_expression ::= binary_expression GE      binary_expression. { INS(GE);      }
binary_expression ::= binary_expression ADDOP   binary_expression. { INS(ADDOP);   }
binary_expression ::= binary_expression SUBOP   binary_expression. { INS(SUBOP);   }
binary_expression ::= binary_expression MULOP   binary_expression. { INS(MULOP);   }
binary_expression ::= binary_expression DIVOP   binary_expression. { INS(DIVOP);   }
binary_expression ::= binary_expression MODOP   binary_expression. { INS(MODOP);   }

// Unary expression
unary_expression ::= postfix_expression. 
unary_expression ::= ADDADD unary_expression. { INS(PREINC); }
unary_expression ::= SUBSUB unary_expression. { INS(PRESUB); }

// Postfix expression
postfix_expression ::= primary_expression. 
postfix_expression ::= postfix_expression ADDADD. { INS(POSTINC); }
postfix_expression ::= postfix_expression SUBSUB. { INS(POSTSUB); } 
postfix_expression ::= postfix_expression DOT id_expression.  
postfix_expression ::= postfix_expression LSBRACKET expression RSBRACKET.  { INS(INDEX); }
postfix_expression ::= function_call .

// Primary expression
primary_expression ::= literal.                         
primary_expression ::= id_expression.
primary_expression ::= LRBRACKET expression RRBRACKET.  
primary_expression ::= list_definition .

// Literals
literal ::= INTEGER(A) . { p->PushRVal(Variant(String(A), Variant::stInt)); }
literal ::= REAL(A) .    { p->PushRVal(Variant(String(A), Variant::stInt)); }
literal ::= STRING(A) .  { p->PushRVal(Variant(String(A), Variant::stString)); }
literal ::= TRUE .       { p->PushRVal(Variant(true)); }
literal ::= FALSE .      { p->PushRVal(Variant(false)); }
literal ::= NULL .       { p->PushRVal(Variant()); }

// Id expression
id_expression ::= IDENTIFIER(A). { INS(LVALUE); PUSHQ(p->GetVar(A)); } 

// List definition
list_definition ::= list_start list_content list_end .
list_start   ::= LSBRACKET . { p->PushRVal(Variant()); }
list_end     ::= RSBRACKET .
list_entry   ::= expression . { INS(ARRAY); }
list_content ::= list_entry . 
list_content ::= list_content COMMA list_entry .

//////////////////////////////////////////////////////////////////////////
//
// Function calls
//

// Function call
function_call ::= function_call_start LRBRACKET argument_list RRBRACKET function_call_end .

// Call parts
function_call_start ::= IDENTIFIER(A) . { PUSHCALL(A); }
function_call_end   ::= .               { POPCALL(); }

// An argument is any expression. If expression lists become part
// of the language, this will have to be changed to something else.
argument ::= expression . { PUSHARG(); }

// Argument list containing 1 or more arguments
arguments ::= argument .
arguments ::= arguments COMMA argument . 

// Argument list
argument_list ::= . 
argument_list ::= arguments . 

//////////////////////////////////////////////////////////////////////////
//
// Declarations
//

// Declaration starting point
declaration ::= VAR declaration_sequence SEMICOLON .
declaration ::= FUN function_declaration .

// Declaration sequence
declaration_sequence ::= var_declaration .
declaration_sequence ::= declaration_sequence COMMA var_declaration .

var_declaration ::= simple_declaration .
var_declaration ::= init_declaration .

// Variable declaration
simple_declaration ::= IDENTIFIER(A) . { 
  INS(VAR);      
  PUSHQ(p->AddVar(A)); 
}

// Variable declaration with initialization
init_declaration ::= IDENTIFIER(A) ASSIGN expression . { 
  INS(VARINIT);  
  PUSHQ(p->AddVar(A)); 
}

// Function declaration
function_declaration ::= function_name LRBRACKET parameter_list parameters_done RRBRACKET function_body .

// Function name
function_name ::= IDENTIFIER(A) . {	p->PushFunction(A); }

// Single parameter
parameter ::= IDENTIFIER(A) . { p->AddParam(A); }

// One or more paremeters
parameters ::= parameter .
parameters ::= parameters COMMA parameter .

// Parameters
parameter_list ::= .
parameter_list ::= parameters .

// Helper - generate code for body
parameters_done ::= . { p->GenFunProlog(); }

// Function-level statements
function_statement ::= statement .
function_statement ::= return_statement .

// Function_statements
function_statements ::= .
function_statements ::= function_statements function_statement .

// Compound statement
function_block ::= function_block_start function_statements function_block_end .
function_block_start ::= LCBRACKET . { PUSHFRAME(); }
function_block_end   ::= RCBRACKET . { POPFRAME();  }

// Function body
function_body ::= function_block . { p->PopFunction(); }

// Return statement - leaves return expression on the stack
return_statement ::= RETURN expression SEMICOLON . { INS(RET); }
return_statement ::= RETURN SEMICOLON . { p->PushRVal(Variant()); INS(RET); }


//////////////////////////////////////////////////////////////////////////
//
// Statements
//

// Expression statement
expression_statement ::= SEMICOLON  .
expression_statement ::= expression SEMICOLON . { INS(POP); }

// Declaration statement
declaration_statement ::= declaration .

// Compound statement
compound_statement ::= compound_start statement_sequence_opt compound_end .
compound_start ::= LCBRACKET . { PUSHFRAME(); }
compound_end   ::= RCBRACKET . { POPFRAME();  }

// Include statement
include_statement ::= INCLUDE STRING(A) SEMICOLON . { p->ParseFile(A); }

// Print statement
//print_statement ::= PRINT LRBRACKET argument_list RRBRACKET SEMICOLON . { INS(PRINT); }

//////////////////////////////////////////////////////////////////////////
//
// For statement
//
// Because reordering of subexpressions is decidedly non-trivial in this
// parser implementation, layout of for expressions is fairly complex:
//
//   init_statement
// 
//   label1:
// 	  condition
// 	  jz label4  <patch 1>
// 	  jmp label3 <patch 2>
// 
//   label2:
// 	  expression
// 	  jmp label1
// 
//   label3:
// 	  statements
// 	  jmp label2
// 
//   label4:
//

// For statement - main structure
for_statement ::= for_start LRBRACKET for_init for_cond SEMICOLON for_expr RRBRACKET for_end . 

// For keyword
for_start ::= FOR . { 
  PUSHFRAME(); 
}

// For init statement
for_init ::= for_init_statement . { 
  p->PushOffset("for_label1"); 
}

// For condition
for_cond ::= for_condition . { 
  INS(JZ);
  p->PushOffset("for_patch_1");
  PUSHQ(0);
  INS(JMP);
  p->PushOffset("for_patch_2");
  PUSHQ(0);
  p->PushOffset("for_label_2"); 
}

// For expression
for_expr ::= expression_opt . { 
  INS(JMP);
  PUSHQ(p->PopOffset("for_label1"));
  PATCH("for_patch_2");
}

// For end
for_end ::= statement . {
  INS(JMP); 
  PUSHQ(p->PopOffset("for_label_2"));
  PATCH("for_patch_1");
  POPFRAME();
}

// For Condition
//for_condition ::= .
for_condition ::= expression .

// Initializer
for_init_statement ::= expression_statement .
for_init_statement ::= declaration_statement .

//////////////////////////////////////////////////////////////////////////
//
// If statement
//
// Layout for the if statement
//
//   condition
//   jz label1 <patch 1>
//
//   statement
//   jmp label2 <patch 2>
//
//   label1:
//   statement
//
//   label2:

%left LOWER_THAN_ELSE.
%left ELSE.

// Main if statement
if_statement ::= IF if_cond statement if_else .

// If condition
if_cond ::= LRBRACKET expression RRBRACKET . {
  INS(JZ);
  p->PushOffset("if_patch_1");
  PUSHQ(0);
}

// Empty else part
if_else ::= . [LOWER_THAN_ELSE] {
  PATCH("if_patch_1");
}

// Filled else part
if_else ::= if_else_1 if_else_2 .

// Prefix part
if_else_1 ::= ELSE . {
  INS(JMP);
  p->PushOffset("if_patch_2");
  PUSHQ(0);
  PATCH("if_patch_1");
}

// Statement part
if_else_2 ::= statement . {
  PATCH("if_patch_2");
}

//////////////////////////////////////////////////////////////////////////
//
// While statement
//

// Basic while
while_statement ::= while_start while_condition while_content .

// While start
while_start ::= WHILE . {
  p->PushOffset("switch_cond_1");
}

// While condition
while_condition ::= LRBRACKET expression RRBRACKET . {
  INS(JZ);
  p->PushOffset("switch_cond_2");
  PUSHQ(0);
}

// While statement
while_content ::= statement . {
  INS(JMP);
  PUSHQ(p->PopOffset("switch_cond_1"));
  PATCH("switch_cond_2");
}

//////////////////////////////////////////////////////////////////////////
//
// Foreach statement
//

foreach_statement ::= foreach_init LRBRACKET for_lvalue IN for_expression RRBRACKET statement foreach_end .

foreach_init ::= FOREACH . { PUSHFRAME(); }

for_lvalue ::= id_expression .
for_lvalue ::= VAR simple_declaration .

for_expression ::= expression . { }

foreach_end ::= . { POPFRAME(); }



