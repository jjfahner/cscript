//////////////////////////////////////////////////////////////////////////
//
// Lemon language definition for cscript
//
//////////////////////////////////////////////////////////////////////////

// Set prefix for tokens
%token_prefix     TOK_
%token_type       { Token* }
%extra_argument   { ParseContext* pContext }


//////////////////////////////////////////////////////////////////////////
//
// Include section
//
%include {

#include "tokens.h"
#include "context.h"

#pragma warning(disable:4065)


} 
//
// End inclusion block
//
//////////////////////////////////////////////////////////////////////////

// Start symbol
translation_unit ::= statement_sequence_opt. { pContext->PushByte(TOK_HALT); }

// Statement sequence
statement_sequence ::= statement. 
statement_sequence ::= statement_sequence statement. 

// Optional statement sequence
statement_sequence_opt ::= . 
statement_sequence_opt ::= statement_sequence. 

// Statement
statement ::= SEMICOLON. 
statement ::= expression  SEMICOLON . 
statement ::= declaration SEMICOLON .

// Expression list
expression_list ::= assignment_expression. 
expression_list ::= expression_list COMMA assignment_expression. 

// Optional expression list
expression_list_opt ::= . 
expression_list_opt ::= expression_list. 

// Expression
expression ::= assignment_expression. { pContext->PushByte(TOK_POP); }
// expression ::= expression COMMA assignment_expression. 

// Assignment
assignment_expression ::= conditional_expression. 
assignment_expression ::= logical_or_expression ASSIGN assignment_expression. { pContext->PushByte(TOK_ASSIGN); }
assignment_expression ::= logical_or_expression ASSADD assignment_expression. { pContext->PushByte(TOK_ASSADD); } 
assignment_expression ::= logical_or_expression ASSSUB assignment_expression. { pContext->PushByte(TOK_ASSSUB); }
assignment_expression ::= logical_or_expression ASSMUL assignment_expression. { pContext->PushByte(TOK_ASSMUL); }
assignment_expression ::= logical_or_expression ASSDIV assignment_expression. { pContext->PushByte(TOK_ASSDIV); }
assignment_expression ::= logical_or_expression ASSMOD assignment_expression. { pContext->PushByte(TOK_ASSMOD); }

// Conditional
conditional_expression ::= logical_or_expression. 
conditional_expression ::= logical_or_expression QUESTION expression COLON assignment_expression. 

// Logical or
logical_or_expression ::= logical_and_expression. 
logical_or_expression ::= logical_or_expression LOGOR logical_and_expression. { pContext->PushByte(TOK_LOGOR); }

// Logical and
logical_and_expression ::= inclusive_or_expression. 
logical_and_expression ::= logical_and_expression LOGAND inclusive_or_expression. { pContext->PushByte(TOK_LOGAND); }

// Bitwise or
inclusive_or_expression ::= exclusive_or_expression. 
inclusive_or_expression ::= inclusive_or_expression BITOR exclusive_or_expression. { pContext->PushByte(TOK_PREINC); }

// Bitwise xor
exclusive_or_expression ::= and_expression. 
exclusive_or_expression ::= exclusive_or_expression BITXOR and_expression. { pContext->PushByte(TOK_BITXOR); }

// Bitwise and
and_expression ::= equality_expression. 
and_expression ::= and_expression BITAND equality_expression. { pContext->PushByte(TOK_BITAND); }

// Equality expression
equality_expression ::= relational_expression. 
equality_expression ::= equality_expression EQUALS  relational_expression. { pContext->PushByte(TOK_EQUALS); }
equality_expression ::= equality_expression NEQUALS relational_expression. { pContext->PushByte(TOK_NEQUALS); }

// Relational expression
relational_expression ::= additive_expression. 
relational_expression ::= relational_expression ST additive_expression. { pContext->PushByte(TOK_ST); }
relational_expression ::= relational_expression SE additive_expression. { pContext->PushByte(TOK_SE); }
relational_expression ::= relational_expression GT additive_expression. { pContext->PushByte(TOK_GT); }
relational_expression ::= relational_expression GE additive_expression. { pContext->PushByte(TOK_GE); }

// Additive expression
additive_expression ::= multiplicative_expression. 
additive_expression ::= multiplicative_expression ADDOP additive_expression. { pContext->PushByte(TOK_ADDOP); }
additive_expression ::= multiplicative_expression SUBOP additive_expression. { pContext->PushByte(TOK_SUBOP); }

// Multiplicative expression
multiplicative_expression ::= unary_expression. 
multiplicative_expression ::= multiplicative_expression MULOP unary_expression. { pContext->PushByte(TOK_MULOP); }
multiplicative_expression ::= multiplicative_expression DIVOP unary_expression. { pContext->PushByte(TOK_DIVOP); }
multiplicative_expression ::= multiplicative_expression MODOP unary_expression. { pContext->PushByte(TOK_MODOP); }

// Unary expression
unary_expression ::= postfix_expression. 
unary_expression ::= ADDADD unary_expression. { pContext->PushByte(TOK_PREINC); }
unary_expression ::= SUBSUB unary_expression. { pContext->PushByte(TOK_PRESUB); }

// Postfix expression
postfix_expression ::= primary_expression. 
postfix_expression ::= postfix_expression ADDADD. { pContext->PushByte(TOK_POSTINC); }
postfix_expression ::= postfix_expression SUBSUB. { pContext->PushByte(TOK_POSTSUB); } 
postfix_expression ::= postfix_expression DOT id_expression.  
postfix_expression ::= postfix_expression LSBRACKET expression RSBRACKET.  
postfix_expression ::= postfix_expression LRBRACKET expression_list_opt RRBRACKET.  

// Primary expression
primary_expression ::= literal.                         
primary_expression ::= id_expression.                   
primary_expression ::= LRBRACKET expression RRBRACKET.  

// Literals
literal ::= INTEGER(A). { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stInt))); }
literal ::= REAL(A).    { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stInt))); }
literal ::= STRING(A).  { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stString))); }
literal ::= TRUE.       { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(true))); }
literal ::= FALSE.      { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(false))); }
literal ::= NULL.       { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant())); }

// Id expression
id_expression ::= IDENTIFIER(A). { pContext->PushByte(TOK_LVALUE); pContext->PushQuad(pContext->GetVar(A->m_text)); } 

//////////////////////////////////////////////////////////////////////////
//
// Declarations
//

// Declaration starting point
declaration ::= VAR declaration_sequence .

// Declaration sequence
declaration_sequence ::= var_declaration .
declaration_sequence ::= declaration_sequence COMMA var_declaration .

// Variable declaration
var_declaration ::= IDENTIFIER(A) . { 
  pContext->PushByte(TOK_VAR);      
  pContext->PushQuad(pContext->AddVar(A->m_text)); 
}

// Variable declaration with initialization
var_declaration ::= IDENTIFIER(A) ASSIGN assignment_expression . { 
  pContext->PushByte(TOK_VARINIT);  
  pContext->PushQuad(pContext->AddVar(A->m_text)); 
}
