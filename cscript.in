//////////////////////////////////////////////////////////////////////////
//
// Lemon language definition for cscript
//
//////////////////////////////////////////////////////////////////////////

// Set prefix for tokens
%name             CScriptParse
%token_prefix     TOK_
%token_type       { Token }
%extra_argument   { Parser* pContext }

// Error handlers
%parse_failure {
  throw std::runtime_error("Parse failed");
}
%syntax_error {
  throw std::runtime_error("Syntax error");
}

//////////////////////////////////////////////////////////////////////////
//
// Include section
//
%include {

#include "tokens.h"
#include "parser.h"

#pragma warning(disable:4065)

//
// Some defines to make the code a bit cleaner
//
#define PUSHB(arg) (pContext->PushByte(arg))
#define PUSHW(arg) (pContext->PushWord(arg))
#define PUSHQ(arg) (pContext->PushQuad(arg))
#define PUSHFRAME()(pContext->PushFrame())
#define POPFRAME() (pContext->PopFrame())
#define PATCH(arg) (pContext->SetQuad(pContext->PopOffset(arg), pContext->GetPos()))
#define FUN(arg)   (pContext->GetFunction(arg))

} 
//
// End inclusion block
//
//////////////////////////////////////////////////////////////////////////


// Precedence rules for binary operators
%left LOGOR .
%left LOGAND .
%left BITOR .
%left BITXOR .
%left BITAND .
%left EQUALS NEQUALS .
%left ST SE GT GE .
%left ADDOP SUBOP .
%left MULOP DIVOP MODOP .
%right ASSIGN ASSADD ASSSUB ASSMUL ASSDIV ASSMOD .


// Start symbol
translation_unit ::= statement_sequence_opt. { PUSHB(TOK_HALT); }

// Statement sequence
statement_sequence ::= statement. 
statement_sequence ::= statement_sequence statement. 

// Optional statement sequence
statement_sequence_opt ::= . 
statement_sequence_opt ::= statement_sequence. 

// Statement
statement ::= include_statement .
statement ::= expression_statement . 
statement ::= declaration_statement .
statement ::= for_statement .
statement ::= compound_statement .
statement ::= if_statement .
statement ::= while_statement .
statement ::= print_statement . // Dirty hack :)

// Expression
expression ::= assignment_expression.

// Optional expression
expression_opt ::= .
expression_opt ::= expression .

// Assignment
assignment_expression ::= conditional_expression . 
assignment_expression ::= binary_expression ASSIGN assignment_expression. { PUSHB(TOK_ASSIGN); }
assignment_expression ::= binary_expression ASSADD assignment_expression. { PUSHB(TOK_ASSADD); } 
assignment_expression ::= binary_expression ASSSUB assignment_expression. { PUSHB(TOK_ASSSUB); }
assignment_expression ::= binary_expression ASSMUL assignment_expression. { PUSHB(TOK_ASSMUL); }
assignment_expression ::= binary_expression ASSDIV assignment_expression. { PUSHB(TOK_ASSDIV); }
assignment_expression ::= binary_expression ASSMOD assignment_expression. { PUSHB(TOK_ASSMOD); }

// Conditional
conditional_expression ::= binary_expression .
conditional_expression ::= cond_part QUESTION cond_expr_true COLON cond_expr_false . 

// Contitional parts
cond_part ::= binary_expression . {
  PUSHB(TOK_JZ);
  pContext->PushOffset(L"cond_exp_1");
  PUSHQ(0);
}
cond_expr_true ::= expression . {
  PUSHB(TOK_JMP);
  pContext->PushOffset(L"cond_exp_2");
  PUSHQ(0);
  pContext->SetQuad(pContext->PopOffset(L"cond_exp_1"), pContext->GetPos());
}
cond_expr_false ::= assignment_expression . {
  pContext->SetQuad(pContext->PopOffset(L"cond_exp_2"), pContext->GetPos());
}

// Binary expressions
binary_expression ::= unary_expression . 
binary_expression ::= binary_expression LOGOR   binary_expression. { PUSHB(TOK_LOGOR);   }
binary_expression ::= binary_expression LOGAND  binary_expression. { PUSHB(TOK_LOGAND);  }
binary_expression ::= binary_expression BITOR   binary_expression. { PUSHB(TOK_PREINC);  }
binary_expression ::= binary_expression BITXOR  binary_expression. { PUSHB(TOK_BITXOR);  }
binary_expression ::= binary_expression BITAND  binary_expression. { PUSHB(TOK_BITAND);  }
binary_expression ::= binary_expression EQUALS  binary_expression. { PUSHB(TOK_EQUALS);  }
binary_expression ::= binary_expression NEQUALS binary_expression. { PUSHB(TOK_NEQUALS); }
binary_expression ::= binary_expression ST      binary_expression. { PUSHB(TOK_ST);      }
binary_expression ::= binary_expression SE      binary_expression. { PUSHB(TOK_SE);      }
binary_expression ::= binary_expression GT      binary_expression. { PUSHB(TOK_GT);      }
binary_expression ::= binary_expression GE      binary_expression. { PUSHB(TOK_GE);      }
binary_expression ::= binary_expression ADDOP   binary_expression. { PUSHB(TOK_ADDOP);   }
binary_expression ::= binary_expression SUBOP   binary_expression. { PUSHB(TOK_SUBOP);   }
binary_expression ::= binary_expression MULOP   binary_expression. { PUSHB(TOK_MULOP);   }
binary_expression ::= binary_expression DIVOP   binary_expression. { PUSHB(TOK_DIVOP);   }
binary_expression ::= binary_expression MODOP   binary_expression. { PUSHB(TOK_MODOP);   }

// Unary expression
unary_expression ::= postfix_expression. 
unary_expression ::= ADDADD unary_expression. { PUSHB(TOK_PREINC); }
unary_expression ::= SUBSUB unary_expression. { PUSHB(TOK_PRESUB); }

// Postfix expression
postfix_expression ::= primary_expression. 
postfix_expression ::= postfix_expression ADDADD. { PUSHB(TOK_POSTINC); }
postfix_expression ::= postfix_expression SUBSUB. { PUSHB(TOK_POSTSUB); } 
postfix_expression ::= postfix_expression DOT id_expression.  
postfix_expression ::= postfix_expression LSBRACKET expression RSBRACKET.  { PUSHB(TOK_INDEX); }
postfix_expression ::= function_call .

// Primary expression
primary_expression ::= literal.                         
primary_expression ::= id_expression.                   
primary_expression ::= LRBRACKET expression RRBRACKET.  

// Literals
literal ::= INTEGER(A). { PUSHB(TOK_RVALUE); PUSHQ(pContext->AddLiteral(A, Variant::stInt)); }
literal ::= REAL(A).    { PUSHB(TOK_RVALUE); PUSHQ(pContext->AddLiteral(A, Variant::stInt)); }
literal ::= STRING(A).  { PUSHB(TOK_RVALUE); PUSHQ(pContext->AddLiteral(A, Variant::stString)); }
literal ::= TRUE.       { PUSHB(TOK_RVALUE); PUSHQ(pContext->AddLiteral(Variant(true))); }
literal ::= FALSE.      { PUSHB(TOK_RVALUE); PUSHQ(pContext->AddLiteral(Variant(false))); }
literal ::= NULL.       { PUSHB(TOK_RVALUE); PUSHQ(pContext->AddLiteral(Variant())); }

// Id expression
id_expression ::= IDENTIFIER(A). { PUSHB(TOK_LVALUE); PUSHQ(pContext->GetVar(A)); } 

//////////////////////////////////////////////////////////////////////////
//
// Function calls
//

// Function call
function_call ::= IDENTIFIER(A) LRBRACKET argument_list RRBRACKET . { PUSHB(TOK_CALL); PUSHQ(FUN(A)); }

// An argument is any expression. If expression lists become part
// of the language, this will have to be changed to something else.
argument ::= expression .

// Argument list containing 1 or more arguments
arguments ::= argument .
arguments ::= arguments COMMA argument . 

// Argument list
argument_list ::= . 
argument_list ::= arguments . 

// Return statements - leaves return expression on the stack
return_statement ::= RETURN expression SEMICOLON . { PUSHB(TOK_RET); }
return_statement ::= RETURN SEMICOLON . { PUSHB(TOK_RVALUE); PUSHQ(pContext->AddLiteral(Variant())); PUSHB(TOK_RET); }

//////////////////////////////////////////////////////////////////////////
//
// Declarations
//

// Declaration starting point
declaration ::= VAR declaration_sequence SEMICOLON .
declaration ::= FUN function_declaration .

// Declaration sequence
declaration_sequence ::= var_declaration .
declaration_sequence ::= declaration_sequence COMMA var_declaration .

// Variable declaration
var_declaration ::= IDENTIFIER(A) . { 
  PUSHB(TOK_VAR);      
  PUSHQ(pContext->AddVar(A)); 
}

// Variable declaration with initialization
var_declaration ::= IDENTIFIER(A) ASSIGN expression . { 
  PUSHB(TOK_VARINIT);  
  PUSHQ(pContext->AddVar(A)); 
}

// Function declaration
function_declaration ::= function_name LRBRACKET parameter_list parameters_done RRBRACKET function_body .

// Function name
function_name ::= IDENTIFIER(A) . {	pContext->PushFunction(A); }

// Single parameter
parameter ::= IDENTIFIER(A) . { pContext->AddParam(A); }

// One or more paremeters
parameters ::= parameter .
parameters ::= parameters COMMA parameter .

// Parameters
parameter_list ::= .
parameter_list ::= parameters .

// Helper - generate code for body
parameters_done ::= . { pContext->GenFunProlog(); }

// Function-level statements
function_statement ::= statement .
function_statement ::= return_statement .

// Function_statements
function_statements ::= .
function_statements ::= function_statements function_statement .

// Compound statement
function_block ::= function_block_start function_statements function_block_end .
function_block_start ::= LCBRACKET . { PUSHFRAME(); }
function_block_end   ::= RCBRACKET . { POPFRAME();  }

// Function body
function_body ::= function_block . { pContext->PopFunction(); }

//////////////////////////////////////////////////////////////////////////
//
// Statements
//

// Expression statement
expression_statement ::= expression_statement_opt SEMICOLON .
expression_statement_opt ::= expression . { PUSHB(TOK_POP); }

// Declaration statement
declaration_statement ::= declaration .

// Compound statement
compound_statement ::= compound_start statement_sequence_opt compound_end .
compound_start ::= LCBRACKET . { PUSHFRAME(); }
compound_end   ::= RCBRACKET . { POPFRAME();  }

// Include statement
include_statement ::= INCLUDE expression SEMICOLON . { /*pContext->Include(A);*/ }

// Print statement
print_statement ::= PRINT LRBRACKET argument_list RRBRACKET SEMICOLON . { PUSHB(TOK_PRINT); }

//////////////////////////////////////////////////////////////////////////
//
// For statement
//
// Because reordering of subexpressions is decidedly non-trivial in this
// parser implementation, layout of for expressions is fairly complex:
//
//   init_statement
// 
//   label1:
// 	  condition
// 	  jz label4  <patch 1>
// 	  jmp label3 <patch 2>
// 
//   label2:
// 	  expression
// 	  jmp label1
// 
//   label3:
// 	  statements
// 	  jmp label2
// 
//   label4:
//

// For statement - main structure
for_statement ::= for_start LRBRACKET for_init for_cond SEMICOLON for_expr RRBRACKET for_end . 

// For keyword
for_start ::= FOR . { 
  PUSHFRAME(); 
}

// For init statement
for_init ::= for_init_statement . { 
  pContext->PushOffset(L"for_label1"); 
}

// For condition
for_cond ::= for_condition . { 
  PUSHB(TOK_JZ);
  pContext->PushOffset(L"for_patch_1");
  PUSHQ(0);
  PUSHB(TOK_JMP);
  pContext->PushOffset(L"for_patch_2");
  PUSHQ(0);
  pContext->PushOffset(L"for_label_2"); 
}

// For expression
for_expr ::= expression_opt . { 
  PUSHB(TOK_JMP);
  PUSHQ(pContext->PopOffset(L"for_label1"));
  PATCH(L"for_patch_2");
}

// For end
for_end ::= statement . {
  PUSHB(TOK_JMP); 
  PUSHQ(pContext->PopOffset(L"for_label_2"));
  PATCH(L"for_patch_1");
  POPFRAME();
}

// For Condition
//for_condition ::= .
for_condition ::= expression .

// Initializer
for_init_statement ::= expression_statement .
for_init_statement ::= declaration_statement .

//////////////////////////////////////////////////////////////////////////
//
// If statement
//
// Layout for the if statement
//
//   condition
//   jz label1 <patch 1>
//
//   statement
//   jmp label2 <patch 2>
//
//   label1:
//   statement
//
//   label2:

%left LOWER_THAN_ELSE.
%left ELSE.

// Main if statement
if_statement ::= IF if_cond statement if_else .

// If condition
if_cond ::= LRBRACKET expression RRBRACKET . {
  PUSHB(TOK_JZ);
  pContext->PushOffset(L"if_patch_1");
  PUSHQ(0);
}

// Empty else part
if_else ::= . [LOWER_THAN_ELSE] {
  PATCH(L"if_patch_1");
}

// Filled else part
if_else ::= if_else_1 if_else_2 .

// Prefix part
if_else_1 ::= ELSE . {
  PUSHB(TOK_JMP);
  pContext->PushOffset(L"if_patch_2");
  PUSHQ(0);
  PATCH(L"if_patch_1");
}

// Statement part
if_else_2 ::= statement . {
  PATCH(L"if_patch_2");
}

//////////////////////////////////////////////////////////////////////////
//
// While statement
//

// Basic while
while_statement ::= while_start while_condition while_content .

// While start
while_start ::= WHILE . {
  pContext->PushOffset(L"switch_cond_1");
}

// While condition
while_condition ::= LRBRACKET expression RRBRACKET . {
  PUSHB(TOK_JZ);
  pContext->PushOffset(L"switch_cond_2");
  PUSHQ(0);
}

// While statement
while_content ::= statement . {
  PUSHB(TOK_JMP);
  PUSHQ(pContext->PopOffset(L"switch_cond_1"));
  PATCH(L"switch_cond_2");
}
