//////////////////////////////////////////////////////////////////////////
//
// Lemon language definition for cscript
//
//////////////////////////////////////////////////////////////////////////

// Set prefix for tokens
%token_prefix     TOK_
%token_type       { Token* }
%extra_argument   { ParseContext* pContext }

// Error handlers
%parse_failure {
  throw std::runtime_error("Parse failed");
}
%syntax_error {
  throw std::runtime_error("Syntax error");
}

//////////////////////////////////////////////////////////////////////////
//
// Include section
//
%include {

#include "tokens.h"
#include "context.h"

#pragma warning(disable:4065)

} 
//
// End inclusion block
//
//////////////////////////////////////////////////////////////////////////

// Start symbol
translation_unit ::= statement_sequence_opt. { pContext->PushByte(TOK_HALT); }

// Statement sequence
statement_sequence ::= statement. 
statement_sequence ::= statement_sequence statement. 

// Optional statement sequence
statement_sequence_opt ::= . 
statement_sequence_opt ::= statement_sequence. 

// Statement
statement ::= expression_statement . 
statement ::= declaration_statement .
statement ::= for_statement .
statement ::= compound_statement .
statement ::= if_statement .
statement ::= print_statement . // Dirty hack :)

// Expression list
expression_list ::= assignment_expression. 
expression_list ::= expression_list COMMA assignment_expression. 

// Optional expression list
expression_list_opt ::= . 
expression_list_opt ::= expression_list. 

// Expression
expression ::= assignment_expression. { pContext->PushByte(TOK_POP); }

// Optional expression
expression_opt ::= .
expression_opt ::= expression .

// Assignment
assignment_expression ::= conditional_expression. 
assignment_expression ::= logical_or_expression ASSIGN assignment_expression. { pContext->PushByte(TOK_ASSIGN); }
assignment_expression ::= logical_or_expression ASSADD assignment_expression. { pContext->PushByte(TOK_ASSADD); } 
assignment_expression ::= logical_or_expression ASSSUB assignment_expression. { pContext->PushByte(TOK_ASSSUB); }
assignment_expression ::= logical_or_expression ASSMUL assignment_expression. { pContext->PushByte(TOK_ASSMUL); }
assignment_expression ::= logical_or_expression ASSDIV assignment_expression. { pContext->PushByte(TOK_ASSDIV); }
assignment_expression ::= logical_or_expression ASSMOD assignment_expression. { pContext->PushByte(TOK_ASSMOD); }

// Conditional
conditional_expression ::= logical_or_expression. 
conditional_expression ::= logical_or_expression QUESTION expression COLON assignment_expression. 

// Logical or
logical_or_expression ::= logical_and_expression. 
logical_or_expression ::= logical_or_expression LOGOR logical_and_expression. { pContext->PushByte(TOK_LOGOR); }

// Logical and
logical_and_expression ::= inclusive_or_expression. 
logical_and_expression ::= logical_and_expression LOGAND inclusive_or_expression. { pContext->PushByte(TOK_LOGAND); }

// Bitwise or
inclusive_or_expression ::= exclusive_or_expression. 
inclusive_or_expression ::= inclusive_or_expression BITOR exclusive_or_expression. { pContext->PushByte(TOK_PREINC); }

// Bitwise xor
exclusive_or_expression ::= and_expression. 
exclusive_or_expression ::= exclusive_or_expression BITXOR and_expression. { pContext->PushByte(TOK_BITXOR); }

// Bitwise and
and_expression ::= equality_expression. 
and_expression ::= and_expression BITAND equality_expression. { pContext->PushByte(TOK_BITAND); }

// Equality expression
equality_expression ::= relational_expression. 
equality_expression ::= equality_expression EQUALS  relational_expression. { pContext->PushByte(TOK_EQUALS); }
equality_expression ::= equality_expression NEQUALS relational_expression. { pContext->PushByte(TOK_NEQUALS); }

// Relational expression
relational_expression ::= additive_expression. 
relational_expression ::= relational_expression ST additive_expression. { pContext->PushByte(TOK_ST); }
relational_expression ::= relational_expression SE additive_expression. { pContext->PushByte(TOK_SE); }
relational_expression ::= relational_expression GT additive_expression. { pContext->PushByte(TOK_GT); }
relational_expression ::= relational_expression GE additive_expression. { pContext->PushByte(TOK_GE); }

// Additive expression
%right ADDOP SUBOP.
additive_expression ::= multiplicative_expression. 
additive_expression ::= multiplicative_expression ADDOP additive_expression. { pContext->PushByte(TOK_ADDOP); }
additive_expression ::= multiplicative_expression SUBOP additive_expression. { pContext->PushByte(TOK_SUBOP); }

// Multiplicative expression
multiplicative_expression ::= unary_expression. 
multiplicative_expression ::= multiplicative_expression MULOP unary_expression. { pContext->PushByte(TOK_MULOP); }
multiplicative_expression ::= multiplicative_expression DIVOP unary_expression. { pContext->PushByte(TOK_DIVOP); }
multiplicative_expression ::= multiplicative_expression MODOP unary_expression. { pContext->PushByte(TOK_MODOP); }

// Unary expression
unary_expression ::= postfix_expression. 
unary_expression ::= ADDADD unary_expression. { pContext->PushByte(TOK_PREINC); }
unary_expression ::= SUBSUB unary_expression. { pContext->PushByte(TOK_PRESUB); }

// Postfix expression
postfix_expression ::= primary_expression. 
postfix_expression ::= postfix_expression ADDADD. { pContext->PushByte(TOK_POSTINC); }
postfix_expression ::= postfix_expression SUBSUB. { pContext->PushByte(TOK_POSTSUB); } 
postfix_expression ::= postfix_expression DOT id_expression.  
postfix_expression ::= postfix_expression LSBRACKET expression RSBRACKET.  
postfix_expression ::= postfix_expression LRBRACKET expression_list_opt RRBRACKET.  

// Primary expression
primary_expression ::= literal.                         
primary_expression ::= id_expression.                   
primary_expression ::= LRBRACKET assignment_expression RRBRACKET.  

// Literals
literal ::= INTEGER(A). { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stInt))); }
literal ::= REAL(A).    { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stInt))); }
literal ::= STRING(A).  { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stString))); }
literal ::= TRUE.       { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(true))); }
literal ::= FALSE.      { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(false))); }
literal ::= NULL.       { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant())); }

// Id expression
id_expression ::= IDENTIFIER(A). { pContext->PushByte(TOK_LVALUE); pContext->PushQuad(pContext->GetVar(A->m_text)); } 

//////////////////////////////////////////////////////////////////////////
//
// Declarations
//

// Declaration starting point
declaration ::= VAR declaration_sequence .

// Declaration sequence
declaration_sequence ::= var_declaration .
declaration_sequence ::= declaration_sequence COMMA var_declaration .

// Variable declaration
var_declaration ::= IDENTIFIER(A) . { 
  pContext->PushByte(TOK_VAR);      
  pContext->PushQuad(pContext->AddVar(A->m_text)); 
}

// Variable declaration with initialization
var_declaration ::= IDENTIFIER(A) ASSIGN assignment_expression . { 
  pContext->PushByte(TOK_VARINIT);  
  pContext->PushQuad(pContext->AddVar(A->m_text)); 
}

//////////////////////////////////////////////////////////////////////////
//
// Statements
//

// Expression statement
expression_statement ::= expression_opt SEMICOLON .

// Declaration statement
declaration_statement ::= declaration SEMICOLON .

// Compound statement
compound_statement ::= compound_start statement_sequence_opt compound_end .
compound_start ::= LCBRACKET . { pContext->PushFrame(); }
compound_end   ::= RCBRACKET . { pContext->PopFrame();  }

// Print statement
print_statement ::= PRINT LRBRACKET assignment_expression RRBRACKET SEMICOLON . { pContext->PushByte(TOK_PRINT); }

//////////////////////////////////////////////////////////////////////////
//
// For statement
//
// Because reordering of subexpressions is decidedly non-trivial in this
// parser implementation, layout of for expressions is fairly complex:
//
//   init_statement
// 
//   label1:
// 	  condition
// 	  jz label4  <patch 1>
// 	  jmp label3 <patch 2>
// 
//   label2:
// 	  expression
// 	  jmp label1
// 
//   label3:
// 	  statements
// 	  jmp label2
// 
//   label4:
//

// For statement - main structure
for_statement ::= for_start LRBRACKET for_init for_cond SEMICOLON for_expr RRBRACKET for_end . 

// For keyword
for_start ::= FOR . { 
  pContext->PushFrame(); 
}

// For init statement
for_init ::= for_init_statement . { 
  pContext->PushOffset(L"for_label1"); 
}

// For condition
for_cond ::= for_condition . { 
  pContext->PushByte(TOK_JZ);
  pContext->PushOffset(L"for_patch_1");
  pContext->PushQuad(0);
  pContext->PushByte(TOK_JMP);
  pContext->PushOffset(L"for_patch_2");
  pContext->PushQuad(0);
  pContext->PushOffset(L"for_label_2"); 
}

// For expression
for_expr ::= expression_opt . { 
  pContext->PushByte(TOK_JMP);
  pContext->PushQuad(pContext->PopOffset(L"for_label1"));
  pContext->SetQuad(pContext->PopOffset(L"for_patch_2"), pContext->GetPos());
}

// For end
for_end ::= statement . {
  pContext->PushByte(TOK_JMP); 
  pContext->PushQuad(pContext->PopOffset(L"for_label_2"));
  pContext->SetQuad(pContext->PopOffset(L"for_patch_1"), pContext->GetPos());
  pContext->PopFrame();
}

// For Condition
//for_condition ::= .
for_condition ::= assignment_expression .

// Initializer
for_init_statement ::= expression_statement .
for_init_statement ::= declaration_statement .

//////////////////////////////////////////////////////////////////////////
//
// If statement
//
// Layout for the if statement
//
//   condition
//   jz label1 <patch 1>
//
//   statement
//   jmp label2 <patch 2>
//
//   label1:
//   statement
//
//   label2:

%left LOWER_THAN_ELSE.
%left ELSE.

// Main if statement
if_statement ::= IF if_cond statement if_else .

// If condition
if_cond ::= LRBRACKET assignment_expression RRBRACKET . {
  pContext->PushByte(TOK_JZ);
  pContext->PushOffset(L"if_patch_1");
  pContext->PushQuad(0);
}

// Empty else part
if_else ::= . [LOWER_THAN_ELSE] {
  pContext->SetQuad(pContext->PopOffset(L"if_patch_1"), pContext->GetPos());
}

// Filled else part
if_else ::= if_else_1 if_else_2 .

// Prefix part
if_else_1 ::= ELSE . {
  pContext->PushByte(TOK_JMP);
  pContext->PushOffset(L"if_patch_2");
  pContext->PushQuad(0);
  pContext->SetQuad(pContext->PopOffset(L"if_patch_1"), pContext->GetPos());
}

// Statement part
if_else_2 ::= statement . {
  pContext->SetQuad(pContext->PopOffset(L"if_patch_2"), pContext->GetPos());
}
