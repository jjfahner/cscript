//////////////////////////////////////////////////////////////////////////
//
// Lemon language definition for cscript
//
//////////////////////////////////////////////////////////////////////////

// Set prefix for tokens
%token_prefix     TOK_
%token_type       { Token* }
%extra_argument   { ParseContext* pContext }

// Error handlers
%parse_failure {
  throw std::runtime_error("Parse failed");
}
%syntax_error {
  throw std::runtime_error("Syntax error");
}

//////////////////////////////////////////////////////////////////////////
//
// Include section
//
%include {

#include "tokens.h"
#include "context.h"

#pragma warning(disable:4065)

} 
//
// End inclusion block
//
//////////////////////////////////////////////////////////////////////////


// Precedence rules for binary operators
%left LOGOR .
%left LOGAND .
%left BITOR .
%left BITXOR .
%left BITAND .
%left EQUALS NEQUALS .
%left ST SE GT GE .
%left ADDOP SUBOP .
%left MULOP DIVOP MODOP .
%right ASSIGN ASSADD ASSSUB ASSMUL ASSDIV ASSMOD .


// Start symbol
translation_unit ::= statement_sequence_opt. { pContext->PushByte(TOK_HALT); }

// Statement sequence
statement_sequence ::= statement. 
statement_sequence ::= statement_sequence statement. 

// Optional statement sequence
statement_sequence_opt ::= . 
statement_sequence_opt ::= statement_sequence. 

// Statement
statement ::= expression_statement . 
statement ::= declaration_statement .
statement ::= for_statement .
statement ::= compound_statement .
statement ::= if_statement .
statement ::= print_statement . // Dirty hack :)

// Expression list
expression_list ::= assignment_expression. 
expression_list ::= expression_list COMMA assignment_expression. 

// Optional expression list
expression_list_opt ::= . 
expression_list_opt ::= expression_list. 

// Expression
expression ::= assignment_expression. { pContext->PushByte(TOK_POP); }

// Optional expression
expression_opt ::= .
expression_opt ::= expression .

// Assignment
assignment_expression ::= conditional_expression . 
assignment_expression ::= binary_expression ASSIGN assignment_expression. { pContext->PushByte(TOK_ASSIGN); }
assignment_expression ::= binary_expression ASSADD assignment_expression. { pContext->PushByte(TOK_ASSADD); } 
assignment_expression ::= binary_expression ASSSUB assignment_expression. { pContext->PushByte(TOK_ASSSUB); }
assignment_expression ::= binary_expression ASSMUL assignment_expression. { pContext->PushByte(TOK_ASSMUL); }
assignment_expression ::= binary_expression ASSDIV assignment_expression. { pContext->PushByte(TOK_ASSDIV); }
assignment_expression ::= binary_expression ASSMOD assignment_expression. { pContext->PushByte(TOK_ASSMOD); }

// Conditional
conditional_expression ::= binary_expression .
conditional_expression ::= cond_part QUESTION cond_expr_true COLON cond_expr_false . 

// Contitional parts
cond_part ::= binary_expression . {
  pContext->PushByte(TOK_JZ);
  pContext->PushOffset(L"cond_exp_1");
  pContext->PushQuad(0);
}
cond_expr_true ::= assignment_expression . {
  pContext->PushByte(TOK_JMP);
  pContext->PushOffset(L"cond_exp_2");
  pContext->PushQuad(0);
  pContext->SetQuad(pContext->PopOffset(L"cond_exp_1"), pContext->GetPos());
}
cond_expr_false ::= assignment_expression . {
  pContext->SetQuad(pContext->PopOffset(L"cond_exp_2"), pContext->GetPos());
}

// Binary expressions
binary_expression ::= unary_expression . 
binary_expression ::= binary_expression LOGOR   binary_expression. { pContext->PushByte(TOK_LOGOR);   }
binary_expression ::= binary_expression LOGAND  binary_expression. { pContext->PushByte(TOK_LOGAND);  }
binary_expression ::= binary_expression BITOR   binary_expression. { pContext->PushByte(TOK_PREINC);  }
binary_expression ::= binary_expression BITXOR  binary_expression. { pContext->PushByte(TOK_BITXOR);  }
binary_expression ::= binary_expression BITAND  binary_expression. { pContext->PushByte(TOK_BITAND);  }
binary_expression ::= binary_expression EQUALS  binary_expression. { pContext->PushByte(TOK_EQUALS);  }
binary_expression ::= binary_expression NEQUALS binary_expression. { pContext->PushByte(TOK_NEQUALS); }
binary_expression ::= binary_expression ST      binary_expression. { pContext->PushByte(TOK_ST);      }
binary_expression ::= binary_expression SE      binary_expression. { pContext->PushByte(TOK_SE);      }
binary_expression ::= binary_expression GT      binary_expression. { pContext->PushByte(TOK_GT);      }
binary_expression ::= binary_expression GE      binary_expression. { pContext->PushByte(TOK_GE);      }
binary_expression ::= binary_expression ADDOP   binary_expression. { pContext->PushByte(TOK_ADDOP);   }
binary_expression ::= binary_expression SUBOP   binary_expression. { pContext->PushByte(TOK_SUBOP);   }
binary_expression ::= binary_expression MULOP   binary_expression. { pContext->PushByte(TOK_MULOP);   }
binary_expression ::= binary_expression DIVOP   binary_expression. { pContext->PushByte(TOK_DIVOP);   }
binary_expression ::= binary_expression MODOP   binary_expression. { pContext->PushByte(TOK_MODOP);   }

// Unary expression
unary_expression ::= postfix_expression. 
unary_expression ::= ADDADD unary_expression. { pContext->PushByte(TOK_PREINC); }
unary_expression ::= SUBSUB unary_expression. { pContext->PushByte(TOK_PRESUB); }

// Postfix expression
postfix_expression ::= primary_expression. 
postfix_expression ::= postfix_expression ADDADD. { pContext->PushByte(TOK_POSTINC); }
postfix_expression ::= postfix_expression SUBSUB. { pContext->PushByte(TOK_POSTSUB); } 
postfix_expression ::= postfix_expression DOT id_expression.  
postfix_expression ::= postfix_expression LSBRACKET expression RSBRACKET.  
postfix_expression ::= postfix_expression LRBRACKET expression_list_opt RRBRACKET.  

// Primary expression
primary_expression ::= literal.                         
primary_expression ::= id_expression.                   
primary_expression ::= LRBRACKET assignment_expression RRBRACKET.  

// Literals
literal ::= INTEGER(A). { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stInt))); }
literal ::= REAL(A).    { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stInt))); }
literal ::= STRING(A).  { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(A->m_text, Variant::stString))); }
literal ::= TRUE.       { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(true))); }
literal ::= FALSE.      { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant(false))); }
literal ::= NULL.       { pContext->PushByte(TOK_RVALUE); pContext->PushQuad(pContext->AddLiteral(Variant())); }

// Id expression
id_expression ::= IDENTIFIER(A). { pContext->PushByte(TOK_LVALUE); pContext->PushQuad(pContext->GetVar(A->m_text)); } 

//////////////////////////////////////////////////////////////////////////
//
// Declarations
//

// Declaration starting point
declaration ::= VAR declaration_sequence .

// Declaration sequence
declaration_sequence ::= var_declaration .
declaration_sequence ::= declaration_sequence COMMA var_declaration .

// Variable declaration
var_declaration ::= IDENTIFIER(A) . { 
  pContext->PushByte(TOK_VAR);      
  pContext->PushQuad(pContext->AddVar(A->m_text)); 
}

// Variable declaration with initialization
var_declaration ::= IDENTIFIER(A) ASSIGN assignment_expression . { 
  pContext->PushByte(TOK_VARINIT);  
  pContext->PushQuad(pContext->AddVar(A->m_text)); 
}

//////////////////////////////////////////////////////////////////////////
//
// Statements
//

// Expression statement
expression_statement ::= expression_opt SEMICOLON .

// Declaration statement
declaration_statement ::= declaration SEMICOLON .

// Compound statement
compound_statement ::= compound_start statement_sequence_opt compound_end .
compound_start ::= LCBRACKET . { pContext->PushFrame(); }
compound_end   ::= RCBRACKET . { pContext->PopFrame();  }

// Print statement
print_statement ::= PRINT LRBRACKET assignment_expression RRBRACKET SEMICOLON . { pContext->PushByte(TOK_PRINT); }

//////////////////////////////////////////////////////////////////////////
//
// For statement
//
// Because reordering of subexpressions is decidedly non-trivial in this
// parser implementation, layout of for expressions is fairly complex:
//
//   init_statement
// 
//   label1:
// 	  condition
// 	  jz label4  <patch 1>
// 	  jmp label3 <patch 2>
// 
//   label2:
// 	  expression
// 	  jmp label1
// 
//   label3:
// 	  statements
// 	  jmp label2
// 
//   label4:
//

// For statement - main structure
for_statement ::= for_start LRBRACKET for_init for_cond SEMICOLON for_expr RRBRACKET for_end . 

// For keyword
for_start ::= FOR . { 
  pContext->PushFrame(); 
}

// For init statement
for_init ::= for_init_statement . { 
  pContext->PushOffset(L"for_label1"); 
}

// For condition
for_cond ::= for_condition . { 
  pContext->PushByte(TOK_JZ);
  pContext->PushOffset(L"for_patch_1");
  pContext->PushQuad(0);
  pContext->PushByte(TOK_JMP);
  pContext->PushOffset(L"for_patch_2");
  pContext->PushQuad(0);
  pContext->PushOffset(L"for_label_2"); 
}

// For expression
for_expr ::= expression_opt . { 
  pContext->PushByte(TOK_JMP);
  pContext->PushQuad(pContext->PopOffset(L"for_label1"));
  pContext->SetQuad(pContext->PopOffset(L"for_patch_2"), pContext->GetPos());
}

// For end
for_end ::= statement . {
  pContext->PushByte(TOK_JMP); 
  pContext->PushQuad(pContext->PopOffset(L"for_label_2"));
  pContext->SetQuad(pContext->PopOffset(L"for_patch_1"), pContext->GetPos());
  pContext->PopFrame();
}

// For Condition
//for_condition ::= .
for_condition ::= assignment_expression .

// Initializer
for_init_statement ::= expression_statement .
for_init_statement ::= declaration_statement .

//////////////////////////////////////////////////////////////////////////
//
// If statement
//
// Layout for the if statement
//
//   condition
//   jz label1 <patch 1>
//
//   statement
//   jmp label2 <patch 2>
//
//   label1:
//   statement
//
//   label2:

%left LOWER_THAN_ELSE.
%left ELSE.

// Main if statement
if_statement ::= IF if_cond statement if_else .

// If condition
if_cond ::= LRBRACKET assignment_expression RRBRACKET . {
  pContext->PushByte(TOK_JZ);
  pContext->PushOffset(L"if_patch_1");
  pContext->PushQuad(0);
}

// Empty else part
if_else ::= . [LOWER_THAN_ELSE] {
  pContext->SetQuad(pContext->PopOffset(L"if_patch_1"), pContext->GetPos());
}

// Filled else part
if_else ::= if_else_1 if_else_2 .

// Prefix part
if_else_1 ::= ELSE . {
  pContext->PushByte(TOK_JMP);
  pContext->PushOffset(L"if_patch_2");
  pContext->PushQuad(0);
  pContext->SetQuad(pContext->PopOffset(L"if_patch_1"), pContext->GetPos());
}

// Statement part
if_else_2 ::= statement . {
  pContext->SetQuad(pContext->PopOffset(L"if_patch_2"), pContext->GetPos());
}
